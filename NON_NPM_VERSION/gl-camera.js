// Generated by CoffeeScript 1.10.0

/*
Author: Jens G. Magnus
 */

(function() {
  var addRotationMouseInput, bindMouseEvents, cameraMouseCapture, canvas, currentMouseX, currentMouseY, current_pitch, current_roll, current_yaw, drawFunction, getCanvasSizeAndRelativeMouseLocation, getViewMatrix, lastMouseX, lastMouseY, limitPitch, max_pitch, min_pitch, onMouseDown, onMouseMove, onMouseUp, onTouchEnd, onTouchMove, onTouchStart, sensitivity, setDrawCallback, smoothingThreshold, springiness, target_pitch, target_roll, target_yaw, updateCamera, updateCameraInterval;

  canvas = null;

  drawFunction = null;

  cameraMouseCapture = false;

  springiness = 15;

  sensitivity = 0.015;

  smoothingThreshold = 0.00001;


  /*
  Rotation
   */

  limitPitch = true;

  min_pitch = -Math.PI / 2.0;

  max_pitch = Math.PI / 2.0;

  current_pitch = 0.0;

  current_yaw = 0.0;

  current_roll = 0.0;

  target_pitch = 0.0;

  target_yaw = 0.0;

  target_roll = 0.0;


  /*
  Mouse
   */

  lastMouseX = 0.0;

  lastMouseY = 0.0;

  currentMouseX = 0.0;

  currentMouseY = 0.0;

  updateCameraInterval = null;

  bindMouseEvents = function(element) {
    canvas = element;
    canvas.onmousedown = onMouseDown;
    canvas.onmouseup = onMouseUp;
    canvas.onmouseleave = onMouseUp;
    canvas.onmousemove = onMouseMove;
    canvas.ontouchstart = onTouchStart;
    canvas.ontouchend = onTouchEnd;
    return canvas.ontouchmove = onTouchMove;
  };

  setDrawCallback = function(cb) {
    return drawFunction = cb;
  };

  getCanvasSizeAndRelativeMouseLocation = function(ev) {
    var bottom, height, left, rect, right, top, width, x, y;
    rect = canvas.getBoundingClientRect();
    left = rect.left + window.pageXOffset;
    right = rect.right + window.pageXOffset;
    top = rect.top + window.pageYOffset;
    bottom = rect.bottom + window.pageYOffset;
    width = right - left;
    height = bottom - top;
    x = ev.clientX - left;
    y = ev.clientY - top;
    return {
      width: width,
      height: height,
      x: x,
      y: y
    };
  };

  onTouchStart = function(ev) {
    ev.preventDefault();
    return onMouseDown(ev.touches[0]);
  };

  onTouchEnd = function(ev) {
    ev.preventDefault();
    return onMouseUp(ev.touches[0]);
  };

  onTouchMove = function(ev) {
    ev.preventDefault();
    return onMouseMove(ev.touches[0]);
  };

  onMouseUp = function(ev) {
    return cameraMouseCapture = false;
  };

  onMouseDown = function(ev) {
    var M;
    cameraMouseCapture = true;
    M = getCanvasSizeAndRelativeMouseLocation(ev);
    lastMouseX = M.x;
    lastMouseY = M.y;
    currentMouseX = M.x;
    return currentMouseY = M.y;
  };

  onMouseMove = function(ev) {
    var M, x, y;
    if (cameraMouseCapture !== true) {
      return;
    }
    M = getCanvasSizeAndRelativeMouseLocation(ev);
    currentMouseX = M.x;
    currentMouseY = M.y;
    x = currentMouseX - lastMouseX;
    y = currentMouseY - lastMouseY;
    addRotationMouseInput(x, y);
    lastMouseX = currentMouseX;
    lastMouseY = currentMouseY;
    if (!updateCameraInterval) {
      return updateCameraInterval = setInterval(updateCamera, 15);
    }
  };

  addRotationMouseInput = function(x, y) {
    target_yaw += x * sensitivity;
    target_pitch += y * sensitivity;
    if (limitPitch) {
      return target_pitch = Math.min(Math.max(target_pitch, min_pitch), max_pitch);
    }
  };

  updateCamera = function(deltaTime) {
    var done, step;
    deltaTime = 0.015;
    step = 1 - Math.exp(Math.log(0.5) * springiness * deltaTime);
    current_pitch += (target_pitch - current_pitch) * step;
    current_yaw += (target_yaw - current_yaw) * step;
    current_roll += (target_roll - current_roll) * step;
    done = true;
    done &= Math.abs(target_pitch - current_pitch) < smoothingThreshold;
    done &= Math.abs(target_yaw - current_yaw) < smoothingThreshold;
    done &= Math.abs(target_roll - current_roll) < smoothingThreshold;
    if (done && updateCameraInterval) {
      clearInterval(updateCameraInterval);
      updateCameraInterval = null;
    }
    if (drawFunction) {
      drawFunction();
    }
    return done;
  };

  getViewMatrix = function() {
    var P, R, V, aspectRatio, qc, qp, qy;
    aspectRatio = canvas.width / canvas.height;
    V = mat4.lookAt(mat4.create(), vec3.fromValues(0, 6, 0), vec3.fromValues(0, 0, 0), vec3.fromValues(0, 0, 1));
    P = mat4.perspective(mat4.create(), 70, aspectRatio, 0.01, 12.0);
    qy = quat.create();
    qp = quat.create();
    quat.rotateZ(qy, qy, current_yaw);
    quat.rotateX(qp, qp, -current_pitch);
    qc = quat.multiply(quat.create(), qp, qy);
    R = mat4.fromQuat(mat4.create(), qc);
    return mat4.multiply(mat4.create(), mat4.multiply(mat4.create(), P, V), R);
  };

  window.glCamera = {
    bindMouseEvents: bindMouseEvents,
    setDrawCallback: setDrawCallback,
    getViewMatrix: getViewMatrix
  };

}).call(this);

//# sourceMappingURL=gl-camera.js.map
