// Generated by CoffeeScript 1.10.0

/*
Author: Jens G. Magnus
 */

(function() {
  var LEFT_MOUSE_BUTTON, MIDDLE_MOUSE_BUTTON, RIGHT_MOUSE_BUTTON, addRotationMouseInput, addTranslationMouseInput, bindMouseEvents, cameraMouseCapture, canvas, currentMouseX, currentMouseY, current_distance, current_pitch, current_position, current_roll, current_yaw, distance_sensitivity, distance_springiness, drawFunction, getCameraMatrix, getCanvasSizeAndRelativeMouseLocation, lastMouseX, lastMouseY, limitPitch, max_pitch, min_pitch, onMouseDown, onMouseMove, onMouseUp, onTouchEnd, onTouchMove, onTouchStart, onWheel, rotation_matrix, rotation_sensitivity, rotation_springiness, setDrawCallback, smoothingThreshold, target_distance, target_pitch, target_position, target_roll, target_yaw, translation_sensitivity, translation_springiness, updateCamera, updateCameraInterval;

  canvas = null;

  drawFunction = null;

  cameraMouseCapture = false;

  smoothingThreshold = 0.00001;


  /*
  Distance
   */

  distance_springiness = 20;

  distance_sensitivity = 0.015;

  current_distance = 6.0;

  target_distance = 6.0;


  /*
  Translation
   */

  translation_springiness = 15;

  translation_sensitivity = 0.015;

  current_position = vec3.create();

  target_position = vec3.create();


  /*
  Rotation
   */

  rotation_springiness = 15;

  rotation_sensitivity = 0.015;

  limitPitch = true;

  min_pitch = -Math.PI / 2.0;

  max_pitch = Math.PI / 2.0;

  current_pitch = 0.0;

  current_yaw = 0.0;

  current_roll = 0.0;

  target_pitch = 0.0;

  target_yaw = 0.0;

  target_roll = 0.0;

  rotation_matrix = mat4.create();


  /*
  Mouse
   */

  LEFT_MOUSE_BUTTON = 0;

  MIDDLE_MOUSE_BUTTON = 1;

  RIGHT_MOUSE_BUTTON = 2;

  lastMouseX = 0.0;

  lastMouseY = 0.0;

  currentMouseX = 0.0;

  currentMouseY = 0.0;

  updateCameraInterval = null;

  bindMouseEvents = function(element) {
    canvas = element;
    canvas.onmousedown = onMouseDown;
    canvas.onmouseup = onMouseUp;
    canvas.onmouseleave = onMouseUp;
    canvas.onmousemove = onMouseMove;
    canvas.onwheel = onWheel;
    canvas.ontouchstart = onTouchStart;
    canvas.ontouchend = onTouchEnd;
    canvas.ontouchmove = onTouchMove;
    return canvas.oncontextmenu = function(ev) {
      ev.preventDefault();
      return false;
    };
  };

  setDrawCallback = function(cb) {
    return drawFunction = cb;
  };

  getCanvasSizeAndRelativeMouseLocation = function(ev) {
    var bottom, height, left, rect, right, top, width, x, y;
    rect = canvas.getBoundingClientRect();
    left = rect.left + window.pageXOffset;
    right = rect.right + window.pageXOffset;
    top = rect.top + window.pageYOffset;
    bottom = rect.bottom + window.pageYOffset;
    width = right - left;
    height = bottom - top;
    x = ev.clientX - left;
    y = ev.clientY - top;
    return {
      width: width,
      height: height,
      x: x,
      y: y
    };
  };

  onTouchStart = function(ev) {
    ev.preventDefault();
    return onMouseDown(ev.touches[0]);
  };

  onTouchEnd = function(ev) {
    ev.preventDefault();
    return onMouseUp(ev.touches[0]);
  };

  onTouchMove = function(ev) {
    ev.preventDefault();
    return onMouseMove(ev.touches[0]);
  };

  onWheel = function(ev) {
    ev.preventDefault();
    target_distance += ev.deltaY * distance_sensitivity;
    target_distance = Math.max(target_distance, 0.0);
    if (!updateCameraInterval) {
      return updateCameraInterval = setInterval(updateCamera, 15);
    }
  };

  onMouseUp = function(ev) {
    return cameraMouseCapture = false;
  };

  onMouseDown = function(ev) {
    var M;
    ev.preventDefault();
    cameraMouseCapture = true;
    M = getCanvasSizeAndRelativeMouseLocation(ev);
    lastMouseX = M.x;
    lastMouseY = M.y;
    currentMouseX = M.x;
    return currentMouseY = M.y;
  };

  onMouseMove = function(ev) {
    var M, x, y;
    ev.preventDefault();
    if (cameraMouseCapture !== true) {
      return;
    }
    M = getCanvasSizeAndRelativeMouseLocation(ev);
    currentMouseX = M.x;
    currentMouseY = M.y;
    x = currentMouseX - lastMouseX;
    y = currentMouseY - lastMouseY;
    switch (ev.button) {
      case LEFT_MOUSE_BUTTON:
        addRotationMouseInput(x, y);
        break;
      case RIGHT_MOUSE_BUTTON:
        addTranslationMouseInput(x, y);
    }
    lastMouseX = currentMouseX;
    lastMouseY = currentMouseY;
    if (!updateCameraInterval) {
      return updateCameraInterval = setInterval(updateCamera, 15);
    }
  };

  addRotationMouseInput = function(x, y) {
    target_yaw += x * rotation_sensitivity;
    target_pitch += y * rotation_sensitivity;
    if (limitPitch) {
      return target_pitch = Math.min(Math.max(target_pitch, min_pitch), max_pitch);
    }
  };

  addTranslationMouseInput = function(x, y) {
    var deltaPosition, inverse_rotation_matrix;
    deltaPosition = vec3.fromValues(x * translation_sensitivity, 0.0, y * translation_sensitivity);
    inverse_rotation_matrix = mat4.invert(mat4.create(), rotation_matrix);
    deltaPosition = vec3.transformMat4(vec3.create(), deltaPosition, rotation_matrix);
    return vec3.add(target_position, target_position, deltaPosition);
  };

  updateCamera = function(deltaTime) {
    var delta_position, distance_step, done, qc, qp, qy, rotation_step, translation_step, updateDistance, updateRotation, updateTranslation;
    deltaTime = 0.015;
    updateRotation = false;
    updateRotation |= Math.abs(target_pitch - current_pitch) > smoothingThreshold;
    updateRotation |= Math.abs(target_yaw - current_yaw) > smoothingThreshold;
    updateRotation |= Math.abs(target_roll - current_roll) > smoothingThreshold;
    if (updateRotation) {
      rotation_step = 1 - Math.exp(Math.log(0.5) * rotation_springiness * deltaTime);
      current_pitch += (target_pitch - current_pitch) * rotation_step;
      current_yaw += (target_yaw - current_yaw) * rotation_step;
      current_roll += (target_roll - current_roll) * rotation_step;
      qy = quat.create();
      qp = quat.create();
      quat.rotateZ(qy, qy, -current_yaw);
      quat.rotateX(qp, qp, current_pitch);
      qc = quat.multiply(quat.create(), qy, qp);
      mat4.fromQuat(rotation_matrix, qc);
    }
    updateTranslation = vec3.squaredDistance(target_position, current_position) > smoothingThreshold;
    if (updateTranslation) {
      translation_step = 1 - Math.exp(Math.log(0.5) * translation_springiness * deltaTime);
      delta_position = vec3.subtract(vec3.create(), target_position, current_position);
      vec3.scaleAndAdd(current_position, current_position, delta_position, translation_step);
    }
    updateDistance = Math.abs(target_distance - current_distance) > smoothingThreshold;
    if (updateDistance) {
      distance_step = 1 - Math.exp(Math.log(0.5) * distance_springiness * deltaTime);
      current_distance += (target_distance - current_distance) * distance_step;
    }
    done = !updateRotation && !updateTranslation && !updateDistance;
    if (done && updateCameraInterval) {
      clearInterval(updateCameraInterval);
      updateCameraInterval = null;
    }
    if (drawFunction) {
      drawFunction();
    }
    return done;
  };

  getCameraMatrix = function() {
    var P, V, aspectRatio, center, eye, up;
    aspectRatio = canvas.width / canvas.height;
    eye = vec3.transformMat4(vec3.create(), vec3.fromValues(0, current_distance, 0), rotation_matrix);
    vec3.add(eye, eye, current_position);
    center = vec3.fromValues(0, 0, 0);
    vec3.add(center, center, current_position);
    up = vec3.transformMat4(vec3.create(), vec3.fromValues(0, 0, 1), rotation_matrix);
    V = mat4.lookAt(mat4.create(), eye, center, up);
    P = mat4.perspective(mat4.create(), 70, aspectRatio, 0.01, 100.0 + target_distance);
    return mat4.multiply(mat4.create(), P, V);
  };

  window.glCamera = {
    bindMouseEvents: bindMouseEvents,
    setDrawCallback: setDrawCallback,
    getCameraMatrix: getCameraMatrix
  };

}).call(this);

//# sourceMappingURL=gl-camera.js.map
