// Generated by CoffeeScript 1.10.0
(function() {
  var canvas, cubeVerticesBuffer, cubeVerticesIndexBuffer, drawScene, getShader, gl, init, initBuffers, initShaders, initWebGL, shaderProgram, vertexPositionAttribute;

  canvas = null;

  gl = null;

  cubeVerticesBuffer = null;

  cubeVerticesIndexBuffer = null;

  shaderProgram = null;

  vertexPositionAttribute = null;

  init = function() {
    canvas = document.getElementById("glcanvas");
    initWebGL();
    if (gl) {
      glCamera.bindMouseEvents(canvas);
      initBuffers();
      initShaders();
      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      gl.clearDepth(1.0);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      return glCamera.setDrawCallback(drawScene);
    }
  };

  initWebGL = function() {
    var error, error1;
    try {
      gl = (canvas.getContext("webgl")) || canvas.getContext("experimental-webgl");
    } catch (error1) {
      error = error1;
      console.log(error);
    }
    if (!gl) {
      alert("Unable to initialize WebGL. Your browser may not suppert it.");
      return gl = null;
    }
  };

  drawScene = function() {
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    gl.enable(gl.CULL_FACE);
    gl.cullFace(gl.BACK);
    gl.useProgram(shaderProgram);
    gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "MVP"), false, glCamera.getViewMatrix());
    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVerticesBuffer);
    gl.vertexAttribPointer(vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVerticesIndexBuffer);
    return gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
  };

  initBuffers = function() {
    var cubeVertexIndices, vertices;
    cubeVerticesBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVerticesBuffer);
    vertices = [-1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    cubeVerticesIndexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVerticesIndexBuffer);
    cubeVertexIndices = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];
    return gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeVertexIndices), gl.STATIC_DRAW);
  };

  initShaders = function() {
    var fragmentShader, vertexShader;
    fragmentShader = getShader(gl, "shader-fs");
    vertexShader = getShader(gl, "shader-vs");
    shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);
    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
      alert("Unable to initialize the shader program: " + gl.getProgramInfoLog(shaderProgram));
    }
    gl.useProgram(shaderProgram);
    vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "VertexPosition");
    return gl.enableVertexAttribArray(vertexPositionAttribute);
  };

  getShader = function(gl, id) {
    var currentChild, shader, shaderScript, theSource;
    shaderScript = document.getElementById(id);
    if (!shaderScript) {
      return null;
    }
    theSource = "";
    currentChild = shaderScript.firstChild;
    while (currentChild) {
      if (currentChild.nodeType === currentChild.TEXT_NODE) {
        theSource += currentChild.textContent;
      }
      currentChild = currentChild.nextSibling;
    }
    shader = null;
    if (shaderScript.type === "x-shader/x-fragment") {
      shader = gl.createShader(gl.FRAGMENT_SHADER);
    } else if (shaderScript.type === "x-shader/x-vertex") {
      shader = gl.createShader(gl.VERTEX_SHADER);
    } else {
      return null;
    }
    gl.shaderSource(shader, theSource);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      alert("An error occurred compiling the shaders: " + gl.getShaderInfoLog(shader));
      return null;
    }
    return shader;
  };

  window.glContext = {
    init: init
  };

}).call(this);

//# sourceMappingURL=context.js.map
